# 람다보다는 메서드 참조를 사용하라

## _람다보다 더 간결한 메서드 참조_

람다가 익명 클래스보다 나은 점 중에서 가장 큰 특징이 간결함이다. 그런데 람다보다 더 간결하게 만드는 방법이 메서드 참조(method reference)다. 다음 코드는 임의의 키와 Integer 값의 매핑을 관리하느 프로그램의 일부다. 키가 맵안에 없다면 키와 숫자 1을 매핑하고 이미 있다면 기존 매핑 값을 증가시킨다.

```js
map.merge(key, 1, (count, incr) -> count + incr);
```

이 코드는 자바 8 때 Map에 추가된 merge 메서드를 사용했다. merge 메서드는 키, 값, 함수를 인수로 받으며 주어진 키가 맵 안에 아직 없다면 주어진 쌍을 그대로 저장한다. 받대로 키가 이미 있다면 함수를 현재 값과 주어진 값에 적용한 다음 그 결과로 현재 값을 덮어쓴다.

깔끔해 보이는 코드지만 매개변수인 count와 incr은 크게 하는 일 없이 공간을 꽤 차지 한다. 자바 8이 되면서 Integer 클래스는 이 람다와 기능이 같은 정적 메서드 sum을 제공하기 시작했다. 람다 대신 메서드 참조를 사용하면 훨씬 짧고 간결한 코드를 얻을 수 있다.

```js
map.merge(key, 1, Integer::sum);
```

매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다.

<br>

## _때로는 메서드 참조보다 람다가 명확할 때도 있다_

어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다. 이런 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬욼 수 있다.

람다로 할 수 없는 일이라먼 메서드 참조로도 할 수 없다. 그렇더라도 메서드 참조를 사용하는 편이 보통은 더 짧고 간결하므로 람다로 구현했을 때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 되어준다. 즉, 람다로 작성할 코드를 새로운 메서드에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 식이다. 메서드 참조에는 기능을 잘 드러내는 이름을 지어줄 수 있고 친절한 설명을 문서로 남길 수도 있다.

IDE들은 람다를 메서드 참조로 대체하라고 권하지만 항상 그런 것은 아니다.

```js
service.execute(GoshThisClassNameIsHumongous::action);
```

이를 람다로 대체하면 다음처럼 된다.

```js
service.execute(() -> action());
```

위와 같은 경우 메서드 참조보다 람다 쪽이 낫다. 같은 선상에서 java,util.function 패키지가 제공하는 제네릭 정적 팩터리 메서드인 Function.identity()를 사용하기보다는 똑같은 기능의 람다(x -> x)를 직접 사용하는 편이 코드도 짧고 명확하다.

<br>

## _메서드 참조 유형_

1. 정적 메서드를 가리키는 메서드 참조

2. 한정적 인스턴스 메서드 참조

   - 정적 참조와 비슷하다. 즉 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같다.

3. 비한정적 인스턴스 메서드 참조

   - 함수 객체를 적용하는 시점에 수신 객체를 알려준다. 이를 위해 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따른다. 비한정적 참조는 주로 스트림 파이프라인에서의 매핑과 필터 함수에 쓰인다.

4. 클래스 생성자

5. 배열 생성자

   | 메서드 참조 유형   | 예                     | 같은 기능을 하는 람다                              |
   | ------------------ | ---------------------- | -------------------------------------------------- |
   | 정적               | Integer::parseInt      | str -> Integer.parseInt(str)                       |
   | 한정적(인스턴스)   | Instant.now()::isAfter | Instant then = Instant.now(); t -> then.isAfter(t) |
   | 비한정적(인스턴스) | String::toLowerCase    | str -> str.toLowerCase()                           |
   | 클래스 생성자      | TreeMap<K,V>::new      | () -> new TreeMap<K,V>())                          |
   | 배열 생성자        | int[]::new             | len -> new int[len]                                |

<br>

## _Conclusion_

메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고 그렇지 않을 때만 람다를 사용한다.
