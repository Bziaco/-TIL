<h2>양도하라</h2>

> 반복 처리에서 고계함수로
- 교계함수를 사용하여 어떤 연산을 할 것인지 표현하는 방법을 익혀라
- 하지만 개발자가 저수준 추상 단계에서 코드가 어떻게 동작하는지 이해하는 과정을 간과해서도 안된다.
- stream같은 추상개념을 사용할 때 거기에 함축된 의미를 반드시 알아야 한다.
- 사용하는 추상화 단계보다 한 단계 아래를 이해하라

> 클로저
- 모든 함수형 언어는 클로저를 포함한다.
- 클로저란 그 내부에서 참조되는 모든 인수에 대한 묵시적 바인딩을 지닌 함수를 칭한다.
- 클로저는 함수형 언어나 프레임워크에서 코드 블록을 다양한 상황에서 실행하게 해주는 매커니즘으로 많이 쓰인다.
    ```
    def Closure makeCounter() {
    def local_variable = 0
    return { return local_variable += 1 }  // <1>
    }

    c1 = makeCounter()    // <2>
    c1()                  // <3>
    c1()
    c1()

    c2 = makeCounter()    // <4>

    println "C1 = ${c1()}, C2 = ${c2()}"
    // output: C1 = 4, C2 = 1  // <5>
    ```
    1. 함수의 리턴 값은 값이 아니라 코드 블록이다.
    2. c1은 이제 이 코드 블록의 인스턴스를 가리킨다.
    3. c1을 불러오면 내부의 인수가 증가한다. 이때 표현을 평가하면 1이 나온다.
    4. c2는 makeCounter()의 새로운 인스턴스를 가리킨다.
    5. 각각의 인스턴스는 local_variable에 다른 내부 상태를 지니고 있다.
    - 여기서 2개의 코드 블록이 각각의 local_variable값을 유지하는 것을 주의해서 보자.
    - 클로저란 단어의 어원이 문맥을 포함함이란 점에서 지역 인수는 함수 내부에서 정의 되지만 코드 블록이 이 인수에 바인딩 되어있고 따라서 코드 블록이 존재하는 동안에 이 인수 값은 유지 되어야 한다.
- 자바8 이전이나 클로저를 지원하지 않는 언어들로도 클로저의 기능을 하는 코드를 만들 수 있지만 그런 경우 개발자가 직접 내부 상태를 관리해야 한다. 왜 클로저의 사용이 함수적 사고를 예시하는지가 여기서 분명해진다.

>커링과 부분적용 / 정의와 차이점
- 커링은 다인수 함수를 일인수 함수들의 체인으로 바꿔주는 방법이다. 이것은 그 변형 과정이지 변형된 함수를 실행하는 것을 지칭하는 것은 아니다.
- 부분적용은 주어진 다인수 함수를 생략될 인수의 값을 미리 정해서 더 적은 수의 인수를 받는 하나의 함수로 변형하는 방법이다. 이 방법은 이름이 의미하듯이 몇몇 인수에 값을 미리 적용하고 나머지 인수만 받는 함수를 리턴한다.
    ```
    def product = {x,y -> x * y}
    def quadrate = product.curry(4);    //(1)
    def octate = product.curry(8);      //(2)

    println "4x4: ${quadrate.call(4)"   //(3)
    println "8x5: ${octate(5)}"         //(4)
    ```
    1. curry()가 매개변수 하나를 고정하고 일인수 함수를 리턴한다.
    2. octate() 함수는 항상 주어진 매개변수의 8배수를 리턴한다.
    3. quadrate() 함수는 일인수 함수이고 Closure 클래스의 call() 메서드를 통해서 호출이 가능하다.
    4. 그루비에는 호출을 간편하게 해주는 문법적 설탕이 있다.
    - 위 예제에서 product는 매개변수 두개를 받는 코드 블록으로 정의 된다.
    - 그루비에 내장된 curry() 메서드를 사용하여 두개의 코드 블록(quadrate, octate)을 만든다.
- 합성은 함수형 언어에서 흔히 쓰이는 조합 기술이다.
    ```
    def composite = { f, g, x -> return f(g(x)) }
    def thirtyTwoer = composite.curry(quadrate, octate)
    ```
    - 두개의 함수를 합성하는 코드 블록을 만들었다.
    - 여기서 합성이란 함수를 호출하여 다른 함수를 리턴하게 함을 말한다.

> 재귀
- 재귀란 자신의 재참조하여 같은 프로세스를 반복한는 것을 말한다.
- 같은 메서드를 반복해서 호출하여 컬렉션을 각 단계마다 줄여가면서 반복 처리하는 것을 말한다.
- 조심해야 할 것은 항상 종료 조건을 보장해야 한다는 점이다.

> 목록의 재조명
- C나 C계열(Java포함)인 개발자들은 목록을 색인된 컬렉션으로 생각한다. 목록의 처음부터 시작해 끝가지 순회하는 방법을 보통 택한다.
- 하지만 함수형 언어는 목록을 다른 각도에서 바라본다. 목록의 첫 요소와 나머지의 조합으로 생각해보자. 그러면 재귀를 사용한 반복처리가 가능해진다.
    ```
    def recurseList(listOfNums) {
    if (listOfNums.size == 0) return;
        println "${listOfNums.head()}"
        recurseList(listOfNums.tail())
    }
    println "\nRecurse List"
    recurseList(numbers)
    ```
    - 개배젼수로 주어진 목록이 비어있으면 리턴하고 아니면 계속 자기자신의 프로세스를 실행한다.
    - 재귀는 모든 플랫폼에서 만병통치약이 될 수는 없지만 길지 않은 목록을 처리하는 데에는 안전하다.
- 기존의 명령형에서의 재귀는 상태를 개발자가 관리하지만 고계함수를 사용한 함수형에서는 언어 자체가 재귀 값을 관리해준다.

> 스트림과 작업 재정렬
- 영리한 런타임은 게으른 작업들을 재정렬 할 수 있다.
- map(), filter()등과 같은 고계함수들은 게으른 함수이다. 최종작업이 호출되지 않는 이상 이들은 결과를 내지 않는다. 그렇기 때문에 map()을 먼저 사용하든 filter()를 먼저 사용하던 중요치 않다. 이는 런타임에 최적화를 맡기는 것이 양도의 중요한 예이다.
